# -*- coding: utf-8 -*-
"""Racoon-Detection

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-qdW_3LSaLRcXPSCow-PORVTMxwAfwaG

# Racoon-Detection
### Author github.com/tushar2704
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os
import cv2
import glob as gb
import tqdm
import tensorflow as tf
from tensorflow.keras import backend as K

postion=pd.read_csv('train_labels_.csv')

postion.head()

postion.shape

#loading data and resize it and collect it in one folder

trainpath = 'Racoon Images/images/'
new_size=128
X_train = []
y_train = []


for path in tqdm.tqdm(postion['filename'].values[:161]):
    orignal_image = cv2.imread(trainpath+path)
    image = cv2.cvtColor(orignal_image, cv2.COLOR_BGR2RGB)
    resized_image = cv2.resize(image , (new_size,new_size))
    X_train.append(resized_image)
print('image reading ...finished')
print('--------------------------------------------------')

X_train=np.array(X_train)

X_train = X_train / 255.0

X_train.shape

img=plt.imread('Racoon Images/images/raccoon-17.jpg')

plt.imshow(img)

index = 0
img=cv2.rectangle(img,
                  (postion['xmin'][index],postion['ymin'][index]),
                  (postion['xmax'][index],postion['ymax'][index]),
                  (255,0,0),2)
plt.imshow(img)

#showing training images with labels
plt.figure(figsize=(20,20))
for n , i in enumerate(range(36)) :
    plt.subplot(6,6,n+1)
    img = cv2.imread(trainpath+str(postion.iloc[i,0]))
    img=cv2.rectangle(img,(postion['xmin'][i],postion['ymin'][i]), (postion['xmax'][i],postion['ymax'][i]) , (255,0,0),2)
    plt.imshow(img)
    plt.axis('off')

#loading data and resize it and collect it in one folder

testpath = 'Racoon Images/images/'
new_size=128
X_test = []
y_test = []

for path in tqdm.tqdm(postion['filename'].values[161:]):
    orignal_image = cv2.imread(testpath+path)
    image = cv2.cvtColor(orignal_image, cv2.COLOR_BGR2RGB)
    resized_image = cv2.resize(image , (new_size,new_size))
    X_test.append(resized_image)

X_test = np.array(X_test)
X_test = X_test / 255.0
print('image reading ...finished')

postion=postion[["width","height","xmin","ymin","xmax","ymax"]]

postion["xmin"] = postion["xmin"] *new_size/postion["width"]
postion["xmax"] = postion["xmax"]*new_size /postion["width"]
postion["ymin"] = postion["ymin"] *new_size/postion["height"]
postion["ymax"] = postion["ymax"] *new_size/postion["height"]

#postion=postion.astype('int32')
postion.drop(['width','height'],axis=1,inplace=True)
postion.head()

y_train=postion.iloc[:161,:]
y_test=postion.iloc[161:,:]

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense ,Flatten ,Conv2D ,MaxPooling2D ,Dropout ,BatchNormalization
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping ,ReduceLROnPlateau ,ModelCheckpoint

"""![image.png](attachment:b19fc442-2f73-4e13-8848-af61f620efc7.png)"""

from tensorflow.keras.backend import epsilon
def loss(gt,pred):
    intersections = 0
    unions = 0
    diff_width = np.minimum(gt[:,0] + gt[:,2], pred[:,0] + pred[:,2]) - np.maximum(gt[:,0], pred[:,0])
    diff_height = np.minimum(gt[:,1] + gt[:,3], pred[:,1] + pred[:,3]) - np.maximum(gt[:,1], pred[:,1])
    intersection = diff_width * diff_height

    # Compute union
    area_gt = gt[:,2] * gt[:,3]
    area_pred = pred[:,2] * pred[:,3]
    union = area_gt + area_pred - intersection

#     Compute intersection and union over multiple boxes
    for j, _ in enumerate(union):
        if union[j] > 0 and intersection[j] > 0 and union[j] >= intersection[j]:
            intersections += intersection[j]
            unions += union[j]

    # Compute IOU. Use epsilon to prevent division by zero
    iou = np.round(intersections / (unions + epsilon()), 4)
    iou = iou.astype(np.float32)
    return iou

def IoU(y_true, y_pred):
    iou = tf.py_function(loss, [y_true, y_pred], tf.float32)
    return iou

#callbacks
EarlyStop=EarlyStopping(patience=5,monitor='val_iou',restore_best_weights=True)
Reduce_LR=ReduceLROnPlateau(monitor='val_iou',verbose=2,factor=0.5,min_lr=0.00001)
model_check=ModelCheckpoint('model.hdf5',monitor='val_iou',verbose=1,save_best_only=True)
callback=[EarlyStop , Reduce_LR,model_check]

#optimizer
optimizer_adam=Adam(learning_rate=0.001,beta_1=0.9,beta_2=0.99)

model=Sequential([
                    Conv2D(64,3,activation='relu',kernel_initializer='he_normal',input_shape=(new_size,new_size,3),kernel_regularizer=tf.keras.regularizers.l2(0.0001)),
                    BatchNormalization(),
                    MaxPooling2D(3),

                    Conv2D(128,3,activation='relu',kernel_initializer='he_normal',kernel_regularizer=tf.keras.regularizers.l2(0.0001)),
                    BatchNormalization(),
                    MaxPooling2D(3),

                    Conv2D(256,3,activation='relu',kernel_initializer='he_normal',kernel_regularizer=tf.keras.regularizers.l2(0.0001)),
                    BatchNormalization(),
                    MaxPooling2D(3),


                    Flatten(),
                    Dense(128,activation='relu',kernel_regularizer=tf.keras.regularizers.l2(0.0001)),
                    Dense(32,activation='relu',kernel_regularizer=tf.keras.regularizers.l2(0.0001)),
                    Dense(4,activation='relu',kernel_initializer='glorot_normal')

])

model.summary()

model.compile(optimizer=optimizer_adam, loss='mse', metrics=[IoU])

history=model.fit(X_train,y_train,validation_data=(X_test,y_test),epochs=200,batch_size=4,
                  steps_per_epoch=len(X_train)//4,
                  callbacks=callback, verbose=1)

#plotting training values
import seaborn as sns
sns.set()


pd.DataFrame(history.history).plot(figsize=(8, 5))
plt.grid(True)
plt.gca().set_ylim(0, 1)
plt.show()

IoU = history.history['IoU']
val_IoU = history.history['val_IoU']
epochs = range(1, len(IoU) + 1)

#accuracy plot
plt.plot(epochs, IoU, color='green', label='Training IoU')
plt.plot(epochs, val_IoU, color='blue', label='Validation IoU')
plt.title('Training and Validation Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend()
plt.show()

img=plt.imread('Racoon Images/images/raccoon-2.jpg')

plt.imshow(img)

image_height, image_width, _ = img.shape
image = cv2.resize(img,(new_size,new_size))
image = image / 255.0

image.shape

image=np.expand_dims(image,axis=0)

region = model.predict(image)[0]

region

x0 = int(region[0] * image_width / new_size)
y0 = int(region[1] * image_height / new_size)
x1 = int((region[2]) * image_width / new_size)
y1 = int((region[3]) * image_height / new_size)

# Display the image
img=plt.imread('Racoon Images/images/raccoon-2.jpg')
plt.imshow(img)
plt.axis('off')
plt.show()
# Create a Rectangle patch
cv2.rectangle(img,(x0, y0), ((x1 - x0) , (y1 - y0)) , (255,0,0),2)

# Add the patch to the Axes
plt.imshow(img)
plt.axis('off')
plt.show()

#showing training images with labels
df=pd.read_csv('train_labels_.csv')[161:]
plt.figure(figsize=(20,20))
for n , i in enumerate(range(12)) :
    plt.subplot(3,4,n+1)

    img = cv2.imread(trainpath+str(df.iloc[i,0]))
    org_img=img.copy()

    image_height, image_width, _ = img.shape


    img = cv2.resize(img,(new_size,new_size))
    img = img / 255.0
    img=np.expand_dims(img,axis=0)
    region = model.predict(img)[0]

    x0 = int(region[0] * image_width / new_size)
    y0 = int(region[1] * image_height / new_size)
    x1 = int((region[2]) * image_width / new_size)
    y1 = int((region[3]) * image_height / new_size)

    cv2.rectangle(org_img,(x0, y0), ((x1 - x0) , (y1 - y0)) , (255,0,0),2)
    plt.imshow(org_img)
    plt.axis('off')



from tensorflow.keras.backend import epsilon
def loss(gt,pred):
    intersections = 0
    unions = 0
    diff_width = np.minimum(gt[:,0] + gt[:,2], pred[:,0] + pred[:,2]) - np.maximum(gt[:,0], pred[:,0])
    diff_height = np.minimum(gt[:,1] + gt[:,3], pred[:,1] + pred[:,3]) - np.maximum(gt[:,1], pred[:,1])
    intersection = diff_width * diff_height

    # Compute union
    area_gt = gt[:,2] * gt[:,3]
    area_pred = pred[:,2] * pred[:,3]
    union = area_gt + area_pred - intersection

#     Compute intersection and union over multiple boxes
    for j, _ in enumerate(union):
        if union[j] > 0 and intersection[j] > 0 and union[j] >= intersection[j]:
            intersections += intersection[j]
            unions += union[j]

    # Compute IOU. Use epsilon to prevent division by zero
    iou = np.round(intersections / (unions + epsilon()), 4)
    iou = iou.astype(np.float32)
    return iou

def IoU(y_true, y_pred):
    iou = tf.py_function(loss, [y_true, y_pred], tf.float32)
    return iou

#callbacks
EarlyStop=EarlyStopping(patience=5,monitor='val_iou',restore_best_weights=True)
Reduce_LR=ReduceLROnPlateau(monitor='val_iou',verbose=2,factor=0.5,min_lr=0.00001)
model_check=ModelCheckpoint('model.hdf5',monitor='val_iou',verbose=1,save_best_only=True)
callback=[EarlyStop , Reduce_LR,model_check]

#optimizer
optimizer_adam=Adam(learning_rate=0.001,beta_1=0.9,beta_2=0.99)

from tensorflow.keras.applications.mobilenet import MobileNet
MB=MobileNet(include_top=False,input_shape=(128,128,3))
MB.trainable=True

model1=Sequential([
                    MB,


                    Flatten(),
                    Dense(128,activation='relu',kernel_regularizer=tf.keras.regularizers.l2(0.0001)),
                    Dense(32,activation='relu',kernel_regularizer=tf.keras.regularizers.l2(0.0001)),
                    Dense(4,activation='relu',kernel_initializer='glorot_normal')

])
optimizer_adam=Adam(learning_rate=0.001,beta_1=0.9,beta_2=0.99)
model1.compile(optimizer=optimizer_adam, loss='mse', metrics=[IoU])

history1=model1.fit(X_train,y_train,validation_data=(X_test,y_test),epochs=200,batch_size=4,
                  steps_per_epoch=len(X_train)//4,
                  callbacks=callback, verbose=1)

#plotting training values
import seaborn as sns
sns.set()


pd.DataFrame(history1.history).plot(figsize=(8, 5))
plt.grid(True)
plt.gca().set_ylim(0, 1)
plt.show()

IoU = history1.history['IoU']
val_IoU = history1.history['val_IoU']
epochs = range(1, len(IoU) + 1)

#accuracy plot
plt.plot(epochs, IoU, color='green', label='Training IoU')
plt.plot(epochs, val_IoU, color='blue', label='Validation IoU')
plt.title('Training and Validation Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend()
plt.show()

#showing training images with labels
df=pd.read_csv('train_labels_.csv')[161:]
plt.figure(figsize=(20,20))
for n , i in enumerate(range(12)) :
    plt.subplot(3,4,n+1)

    img = cv2.imread(trainpath+str(df.iloc[i,0]))
    org_img=img.copy()

    image_height, image_width, _ = img.shape


    img = cv2.resize(img,(new_size,new_size))
    img = img / 255.0
    img=np.expand_dims(img,axis=0)
    region = model1.predict(img)[0]

    x0 = int(region[0] * image_width / new_size)
    y0 = int(region[1] * image_height / new_size)
    x1 = int((region[2]) * image_width / new_size)
    y1 = int((region[3]) * image_height / new_size)

    cv2.rectangle(org_img,(x0, y0), ((x1 - x0) , (y1 - y0)) , (255,0,0),2)
    plt.imshow(org_img)
    plt.axis('off')